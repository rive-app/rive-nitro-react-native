///
/// HybridRiveViewSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include "HybridRiveViewSpec.hpp"

// Forward declaration of `HybridRiveViewSpec_cxx` to properly resolve imports.
namespace Rive { class HybridRiveViewSpec_cxx; }

// Forward declaration of `HybridRiveFileSpec` to properly resolve imports.
namespace margelo::nitro::rive { class HybridRiveFileSpec; }
// Forward declaration of `Alignment` to properly resolve imports.
namespace margelo::nitro::rive { enum class Alignment; }
// Forward declaration of `Fit` to properly resolve imports.
namespace margelo::nitro::rive { enum class Fit; }
// Forward declaration of `HybridViewModelInstanceSpec` to properly resolve imports.
namespace margelo::nitro::rive { class HybridViewModelInstanceSpec; }
// Forward declaration of `DataBindMode` to properly resolve imports.
namespace margelo::nitro::rive { enum class DataBindMode; }
// Forward declaration of `DataBindByName` to properly resolve imports.
namespace margelo::nitro::rive { struct DataBindByName; }
// Forward declaration of `RiveError` to properly resolve imports.
namespace margelo::nitro::rive { struct RiveError; }
// Forward declaration of `RiveErrorType` to properly resolve imports.
namespace margelo::nitro::rive { enum class RiveErrorType; }
// Forward declaration of `UnifiedRiveEvent` to properly resolve imports.
namespace margelo::nitro::rive { struct UnifiedRiveEvent; }
// Forward declaration of `RiveEventType` to properly resolve imports.
namespace margelo::nitro::rive { enum class RiveEventType; }

#include <string>
#include <optional>
#include <memory>
#include "HybridRiveFileSpec.hpp"
#include "Alignment.hpp"
#include "Fit.hpp"
#include "HybridViewModelInstanceSpec.hpp"
#include "DataBindMode.hpp"
#include "DataBindByName.hpp"
#include <variant>
#include "RiveError.hpp"
#include <functional>
#include "RiveErrorType.hpp"
#include <NitroModules/Promise.hpp>
#include "UnifiedRiveEvent.hpp"
#include "RiveEventType.hpp"
#include <unordered_map>

#include "Rive-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::rive {

  /**
   * The C++ part of HybridRiveViewSpec_cxx.swift.
   *
   * HybridRiveViewSpecSwift (C++) accesses HybridRiveViewSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridRiveViewSpec_cxx can directly inherit from the C++ class HybridRiveViewSpec
   * to simplify the whole structure and memory management.
   */
  class HybridRiveViewSpecSwift: public virtual HybridRiveViewSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridRiveViewSpecSwift(const Rive::HybridRiveViewSpec_cxx& swiftPart):
      HybridObject(HybridRiveViewSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline Rive::HybridRiveViewSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }
    void dispose() noexcept override {
      _swiftPart.dispose();
    }
    std::string toString() override {
      return _swiftPart.toString();
    }

  public:
    // Properties
    inline std::optional<std::string> getArtboardName() noexcept override {
      auto __result = _swiftPart.getArtboardName();
      return __result;
    }
    inline void setArtboardName(const std::optional<std::string>& artboardName) noexcept override {
      _swiftPart.setArtboardName(artboardName);
    }
    inline std::optional<std::string> getStateMachineName() noexcept override {
      auto __result = _swiftPart.getStateMachineName();
      return __result;
    }
    inline void setStateMachineName(const std::optional<std::string>& stateMachineName) noexcept override {
      _swiftPart.setStateMachineName(stateMachineName);
    }
    inline std::optional<bool> getAutoPlay() noexcept override {
      auto __result = _swiftPart.getAutoPlay();
      return __result;
    }
    inline void setAutoPlay(std::optional<bool> autoPlay) noexcept override {
      _swiftPart.setAutoPlay(autoPlay);
    }
    inline std::shared_ptr<HybridRiveFileSpec> getFile() noexcept override {
      auto __result = _swiftPart.getFile();
      return __result;
    }
    inline void setFile(const std::shared_ptr<HybridRiveFileSpec>& file) noexcept override {
      _swiftPart.setFile(file);
    }
    inline std::optional<Alignment> getAlignment() noexcept override {
      auto __result = _swiftPart.getAlignment();
      return __result;
    }
    inline void setAlignment(std::optional<Alignment> alignment) noexcept override {
      _swiftPart.setAlignment(alignment);
    }
    inline std::optional<Fit> getFit() noexcept override {
      auto __result = _swiftPart.getFit();
      return __result;
    }
    inline void setFit(std::optional<Fit> fit) noexcept override {
      _swiftPart.setFit(fit);
    }
    inline std::optional<double> getLayoutScaleFactor() noexcept override {
      auto __result = _swiftPart.getLayoutScaleFactor();
      return __result;
    }
    inline void setLayoutScaleFactor(std::optional<double> layoutScaleFactor) noexcept override {
      _swiftPart.setLayoutScaleFactor(layoutScaleFactor);
    }
    inline std::optional<std::variant<std::shared_ptr<HybridViewModelInstanceSpec>, DataBindMode, DataBindByName>> getDataBind() noexcept override {
      auto __result = _swiftPart.getDataBind();
      return __result;
    }
    inline void setDataBind(const std::optional<std::variant<std::shared_ptr<HybridViewModelInstanceSpec>, DataBindMode, DataBindByName>>& dataBind) noexcept override {
      _swiftPart.setDataBind(dataBind);
    }
    inline std::function<void(const RiveError& /* error */)> getOnError() noexcept override {
      auto __result = _swiftPart.getOnError();
      return __result;
    }
    inline void setOnError(const std::function<void(const RiveError& /* error */)>& onError) noexcept override {
      _swiftPart.setOnError(onError);
    }

  public:
    // Methods
    inline std::shared_ptr<Promise<bool>> awaitViewReady() override {
      auto __result = _swiftPart.awaitViewReady();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void bindViewModelInstance(const std::shared_ptr<HybridViewModelInstanceSpec>& viewModelInstance) override {
      auto __result = _swiftPart.bindViewModelInstance(viewModelInstance);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::optional<std::shared_ptr<HybridViewModelInstanceSpec>> getViewModelInstance() override {
      auto __result = _swiftPart.getViewModelInstance();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void play() override {
      auto __result = _swiftPart.play();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void pause() override {
      auto __result = _swiftPart.pause();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void onEventListener(const std::function<void(const UnifiedRiveEvent& /* event */)>& onEvent) override {
      auto __result = _swiftPart.onEventListener(onEvent);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void removeEventListeners() override {
      auto __result = _swiftPart.removeEventListeners();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setNumberInputValue(const std::string& name, double value, const std::optional<std::string>& path) override {
      auto __result = _swiftPart.setNumberInputValue(name, std::forward<decltype(value)>(value), path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline double getNumberInputValue(const std::string& name, const std::optional<std::string>& path) override {
      auto __result = _swiftPart.getNumberInputValue(name, path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void setBooleanInputValue(const std::string& name, bool value, const std::optional<std::string>& path) override {
      auto __result = _swiftPart.setBooleanInputValue(name, std::forward<decltype(value)>(value), path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline bool getBooleanInputValue(const std::string& name, const std::optional<std::string>& path) override {
      auto __result = _swiftPart.getBooleanInputValue(name, path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void triggerInput(const std::string& name, const std::optional<std::string>& path) override {
      auto __result = _swiftPart.triggerInput(name, path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setTextRunValue(const std::string& name, const std::string& value, const std::optional<std::string>& path) override {
      auto __result = _swiftPart.setTextRunValue(name, value, path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::string getTextRunValue(const std::string& name, const std::optional<std::string>& path) override {
      auto __result = _swiftPart.getTextRunValue(name, path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }

  private:
    Rive::HybridRiveViewSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::rive
